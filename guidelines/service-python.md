Реализация сервисов на Python
=============================

В этом гайдлайне описаны best-practices по созданию сервисов с помощью Python.

Общие требования к сервисам (коды возвратов, настройки systemd) можно почитать
в остальных гайдлайнах в этой директории.


Особенности работы с paho.mqtt
------------------------------

### Инициализация и подписки

Отправлять сообщения при старте и подписываться на топики надо в обработчике
события `on_connect` (или по сигналу от этого обработчика).

Если это сделать просто после вызова метода `connect()`, подписки и мета
не будут восстановлены в случае перезапуска брокера или потери связи с ним.

Также стоит смотреть, какой код вернулся в аргументе `rc` в `on_connect`
и гасить сервис соответствующим образом. Например, код 4 и 5 означают проблемы
с аутентификацией, а значит, надо завершаться с кодом 6 (NOTCONFIGURED)
и systemd не должен пытаться перезапускать сервис до потери пульса.

> :warning: Нужен гайдлайн о том, как аккуратно построить приложение,
> в котором будет обрабатываться код rc.

### Использовать `loop_forever` или `loop_start` вместо `loop`

По названию метода может показаться, что `loop_forever()` внутри содержит

```python3
...

def loop_forever(self):
    while self._do_run:
        self.loop()
```

На самом деле, внутри библиотеки `paho.mqtt` в `loop_forever()` реализована
логика переподключения к брокеру в случаях разрыва соединения.

Это же касается `loop_start()/loop_stop()`, которые запускают тред, внутри
которого запущена `loop_forever()`.

Использование `loop` вместо `loop_forever` без должного отслеживания
соединений чревато ситуациями, когда из-за перезапуска брокера или потери
соединения процесс начинает потреблять 100% CPU без видимых причин, при
этом соединение не восстанавливается. Пример:
https://wirenboard.bitrix24.ru/company/personal/user/28/tasks/task/view/52850/


### Аккуратная остановка сервиса

Чтобы останавливать сервисы аккуратно, лучше использовать `signal`
для перехвата `signal.SIGTERM` (остановка через `systemctl stop`)
и `signal.SIGINT` (остановка через Ctrl-C в консоли).

Это лучше, чем перехват `KeyboardInterrupt`, потому что нет аналога
`KeyboardInterrupt` при отправке `SIGTERM`, и лучше, чтобы механизмы
остановки были одинаковыми при обоих сигналах.

Если сервис использует `paho.mqtt`, надо при этом аккуратно завершить
цикл.

При использовании `loop_forever` в обработчике сигнала надо вызвать
`client.disconnect()` и не завершать процесс. В таком случае выполнение
после обработки сигнала вернётся в `loop_forever`, которая завершится.

> @webconn проверил, что `loop_forever` завершится после `disconnect`
> и в случае, когда брокер работает, и когда соединение прервалось
> (т.е. `loop_forever()` пытается восстановить соединение).

Стоит отметить, что в этом случае при завершении не получится просто
так отправить сообщения в MQTT из обработчика сигнала, потому что
цикл сразу остановится. Если при остановке сервиса обычно нужно что-то
отправлять в MQTT, есть смысл использовать `loop_start`/`loop_stop`.

При использовании `loop_start` в обработчике надо вызвать `loop_stop`.

> :warning: Нужно уточнение касательно `loop_start`/`loop_stop`,
> достаточно ли просто остановить поток. Также хорошо бы приложить
> примеры хорошего кода в основном потоке для этих случаев.


Ссылки
------

  * http://www.steves-internet-guide.com/client-connections-python-mqtt/ -
    тут можно прочитать о практиках использования paho.mqtt в python
