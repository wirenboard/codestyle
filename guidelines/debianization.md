# Дебианизация (нового/существующего проекта)

Disclaimer: данный гайдлайн стоит воспринимать как выжимку полезностей, а не строгую последовательность действий.

Предполагаемый путь: _понять, что требуется -> посмотреть в [типовых кейсах](#примеры-разных-сценариев) аналогичное -> непонятно - почитать здесь -> отправиться в документацию уже зная, что искать_.

## Тезисно
Для удобного распространения и установки софта, его пакетируют. Deb - самый популярный формат пакетов (используется в *Ubuntu, Debian, у нас на контроллерах). Настройка проекта, чтобы он собирался в .deb пакеты - _дебианизация_.

_Hint:_ .deb лучше всего устанавливать так: ``apt update; apt install -y ./файл.deb`` (через apt, а не dpkg; для автоматического разрешения зависимостей).


### Устройство deb-пакета

- _Исходная система_ - где происходит сборка deb-пакета. В терминологии debian - **build**-система
- _Целевая система_ - куда устанавливается пакет. В терминологии debian - **host**-система

Исполняемые файлы (результаты сборки проекта/скрипты/...) + запаковка их в .deb-пакет (да-да, почти обычный архив) + мета-информация (зависимости/changelog/...) + dh-скрипты (выполняются на целевой системе при/перед/после установки/удаления пакета) = deb-пакет.

Со стороны разработчика, _deb-пакет = source-пакет + binary-пакет/ы_. Из одного source-пакета получаются один или несколько binary-пакетов (которые уже и устанавливаются на целевую систему). См ``debian/control`` далее.

В корень проекта добавляется директория _debian_ с магическими файлами.

Для успешной дебианизации нужно:
- уметь собирать проект
- "рассказать" dh-утилитам, как проект собирается


## Минимальная дебианизация
Минимально необходимые магические файлы в директории _debian_ - это:
- **control** - описывает, какие binary-пакеты получаются из source-пакета; зависимости между пакетами
- **changelog** - чейнджлог; лучше делать утилитой ``dch``
- **compat** - совместимость с вспомогательными скриптами debian. Ставить 9 и не думать (_с переходом на bullseye - ставить 11_)
- **copyright** - можно оставлять пустым
- **rules** - запуск системы сборки (не обязательно make!)
Подробно можно почитать в [доках](https://www.debian.org/doc/manuals/maint-guide/dreq.ru.html)

### Control - всему голова
Именно здесь живут основные настройки пакета. Подробно и понятно о содержании файла control можно почитать в [доке](https://www.debian.org/doc/debian-policy/ch-controlfields).
Дополнительно для нас, обязательны поля:
- ``Homepage``: страница проекта на нашем github. Нужно для ci.
- ``Maintainer``: сотрудник, ответственный за репозиторий. Добавляет порядка.

### О чейнджлогах
Почитав умные статьи вроде [этой](https://cbea.ms/git-commit/), мы приняли решение утвердить формат записей в чейнджлог (и commit messages): _Следует писать на английском в повелительном наклонении. Образец: "add <что_было_добавлено>" - ок. "add**ed** <что_было_добавлено>" или "<что_было_добавлено> is added" - не ок_.
Вносим записи в changelog пакета **при любом** изменении кода (попадающего в master / release*).

### Магические файлы
Об опциональных файлах в директории debian можно почитать в [доке](https://www.deNBbian.org/doc/manuals/maint-guide/dother.ru.html). _Если из одного source-пакета собираются несколько бинарных пакетов - справедливо: вместо <файл_магии> - назвать <название_бинарного_пакета>.<файл_магии>_ (будет работать для указанного бинарного пакета, соответственно).

Чаще всего пригождаются:
- ``debian/packagename.dirs``: директории, необходимые для работы проекта (но не необходимые для установки; например - файлы, появляющиеся в процессе работы). Удаляются при удалении пакета.
- ``debian/packagename.install``: помещаем сюда файлы, которые нужно положить в пакет (если это не делает make install).
- ``debian/packagename.service``: systemd-сервис. Устанавливается автоматически при установке пакета (для автозапуска - прописать соответствующее в rules).
- ``debian/packagename.displace``: замена существующих файлов на файлы из пакета. При удалении пакета, исходные файлы возвращаются. Подробнее - в [доках](https://manpages.debian.org/jessie/config-package-dev/dh_configpackage.1).
- ``debian/packagename.preinst/postinst/prerm/postrm/...``: maintainer-скрипты. Выполняются на разных этапах установки/удаления пакетов. Подробно почитать, что происходит при установке/удалении пакета можно в [доках](https://wiki.debian.org/MaintainerScripts).

### Как файлы проекта попадают в пакет
Директория debian в проекте (исходная система) содержит структуру директорий относительно корня целевой системы. По умолчанию, запуск системы сборки (rules) в конце-концов вызывает _make install_ (относительно директории _debian/_ проекта).

В дебианизации можно переопределить практически что угодно. Например, если нужно пакетировать скрипты/уже готовые бинарники - можно в файле rules не вызывать систему сборки (её вообще может не быть), а добавить в debian/ файл <бинарный_пакет>.install, в котором прописано, какой файл куда класть.

**=> для попадания файлов проекта в пакет, должно быть что-то из:**
- ``Makefile`` с таргетом _install_ внутри
- ``debian/packagename.install`` с описанием внутри, что куда класть

### Сборка
В общем случае, сборка пакета инициируется запуском ``dpkg-buildpackage -rfakeroot -us -uc`` в корне проекта. При сборке бинарников системой сборки, вызываемой в файле rules, могут возникнуть проблемы, связанные с архитектурой => при разработке под WB, **пакеты собирать стоит через [wbdev](https://github.com/wirenboard/wirenboard/blob/master/README.md)**. _Стоит не забывать периодически обновлять devenv (``docker pull contactless/devenv``)_.

Для сборки - выполнить в корне проекта:
- C/C++: ``wbdev cdeb``
- Go: ``wbdev gdeb``
- Noarch (Python/Bash/wbrules/configs/...): ``wbdev ndeb``

### Сборка на билдсервере (далее - Jenkins)
То же самое рабочее окружение (wbdev) используется и для сборки проектов на Jenkins. Здесь мы используем подход _infrastructure as code_, поэтому сборка проектов реализована в виде пайплайнов (подробнее про пайплайны у нас можно почитать [на intwiki](https://intwiki.contactless.ru/dokuwiki/doku.php?id=soft:jenkins)).

Jenkins собирает проект при:
- пуше в веточку
- открытии pr

Концептуально это сделано с помощью: веб-хуков github; плагина для Jenkins (позволяющего описывать этапы сборки в виде кода); непосредственно этапов сборки.

Для того, чтобы Jenkins понимал, что этот проект ему надо собирать, **нужно добавить в корень проекта файл ``Jenkinsfile``** с описанием, что ему делать ([пайплайн](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/)).

Типовые сценарии сборки Jenkins'ом у нас реализованы, и живут [здесь](https://github.com/wirenboard/jenkins-pipeline-lib). Соответственно, для сборки рядового проекта, в Jenkinsfile часто достаточно:
- С/C++: ``buildDebSbuild defaultTargets: 'current-armhf'``
- Go: ``buildDebGolangWbgo()``
- Noarch (Bash/Python/wb-rules/...): ``buildDebArchAll()``

Параметры для вызовов можно подглядеть в соответствующе названных файлах в репозитории выше. Как эти параметры передаются - можно подглядеть в [wb-mqtt-serial](https://github.com/wirenboard/wb-mqtt-serial/blob/master/Jenkinsfile).


## Успешный старт нового репозитория
Для того, чтобы проект заехал в нашу инфраструктуру (собирался на Jenkins, вписался в систему релизов), нужно (со стороны github):

- дать доступ группе ``buildserver-robots`` - для релизной системы
- сделать дебианизацию
- добавить Jenkinsfile - настройки сборки на билдсервере


## Примеры разных сценариев
Дебианизация и документация по ней - обширный мир, который можно уйти надолго => часто бывает проще подсмотреть типовой сценарий и сделать аналогично:

[serial_tool](https://github.com/wirenboard/serial_tool) - готовый скрипт, который надо положить в /usr/bin/. Собирается Make'ом; в rules прописан вызов Make'a.

[wb-mcu-fw-updater](https://github.com/wirenboard/wb-mcu-fw-updater) - состоит из "бинарника" и библиотеки. Из одного source-пакета получается 2 binary-пакета. Собирается pubuild'ом вместо Make; в rules прописан вызов pybuild. _Каноничный способ дебианизации python-проекта_.

[wb-demokit-configs](https://github.com/wirenboard/wb-demo-kit-configs) - нужно положить на контроллер некоторые файлы (с заменой существующих!). В этом нам помогают .displace файлы.

[wb-mcu-fw-flasher](https://github.com/wirenboard/wb-mcu-fw-flasher) - классическая сборка Makefile'ом; в rules просто вызывается make. Прописанное в .dirs очищается при удалении пакета.

[test-suite](https://github.com/wirenboard/test-suite/tree/master/debian) - сложная дебианизация. Из одного source собирается куча binary-пакетов (каждый с разными файлами). Действия перед/после установки/удаления пакета в целевой системе прописаны в .postinst/.postrm/...


## Продвинутые техники
- Диалоговое окно с настройками (на синем фоне) формируется утилитой debconf (проще всего понять на примерах в [test-suite](https://github.com/wirenboard/test-suite/tree/master/debian)).
- Про взаимоотношения между пакетами можно почитать в [доке](https://wiki.debian.org/PackageTransition).


# Правильная подготовка debian/control

Для сборки deb-пакетов в Wiren Board используется кросс-компиляция. Это значит, что сборка
будет происходить на машине с архитектурой, отличной от той, на которой всё будет запускаться.
Самый типовой сценарий - сборка на amd64, выполнение на armhf.

Иногда нужно подсказать сборщику пакетов, как правильно разрешать зависимости.

В этом разделе расписаны несколько типовых сценариев и примеры правильного составления `debian/control`.


## Библиотеки python (без платформо-зависимого кода)

> :warning: Этот раздел ещё не закончен. Нужно уточнить и мотивировать все остальные
> моменты, специфичные для Python.

Этот раздел касается пакетов с python-библиотеками, которые напрямую не зависят от архитектуры
(написаны на чистом python).

Необходимые вещи в `debian/control` в секции `Source`:

```
Source: wb-my-lib
...
Build-Depends: python3-all, dh-python, ...
```

`python3-all` нужно использовать вместо `python3`, потому что так принято в Debian: это
отвязывает процедуру сборки от конкретной реализации Python (CPython, как правило).
А ещё `python3-all` автоматически тянет в своих зависимостях `distutils` подходящей версии.
Так сделано в пакетах в основном репозитории Debian. В общем, так надо.

Писать `python3-all:any` в пакетах-библиотеках обычно не имеет смысла, т.к. при
сборке `arch-all` нет проблем с выбором архитектур.

В секцию `Package` необходимо прописать строки:

```
...

Package: python3-wb-my-lib
Architecture: all
Depends: ${python3:Depends}, ${misc:Depends}, ...
...
```

`Architecture: all` (не путать с `Architecture: any`) нужен для того, чтобы собранный пакет был
платформо-независимый.

Не надо прописывать `python3` в зависимости к таким пакетам,
они добавятся через `${python3:Depends}`.

*В python-библиотеках мы специально не пишем Multi-Arch, см. [ниже](#Почему%20именно%20так)*.


## Кодогенерация при кросс-компиляции

У нас этот сценарий применяется в [wb-mqtt-serial](https://github.com/wirenboard/wb-mqtt-serial/).
Кодогенерация там - сборка шаблонов с помощью `j2cli`.

Для того, чтобы установить `j2cli`, совместимый с архитектурой сборщика, используем `:native`.

```
Source: wb-mqtt-serial
...
Build-Depends: ..., j2cli:native
```


# Почему именно так

Тут собраны аргументированные доводы для тех, кто хочет оспорить текущее положение дел в сборке,
чтобы успокоить пытливые умы и не пройтись по старым граблям при рефакторинге.


### Почему all-пакеты не собираются в sbuild с `--host=armhf`?

Альтернативная формулировка - почему all-пакеты нельзя было раньше собрать через `wbdev cdeb`.

Во-первых, потому что в Debian обычно делят сборку all-пакетов и кросс-компиляцию,
вот ([пруф](https://wiki.debian.org/CrossBuildPackagingGuidelines)).

Во-вторых, это могло бы заработать, если бы мейнтейнеры Python-библиотек в Debian озадачивались
добавлением `Multi-Arch: foreign` в свои пакеты. На ноябрь 2022 этой пометки нет как минимум
в `python3-paho-mqtt` и `python3-jinja2`, а эти пакеты мы часто используем.

В итоге оказалось проще пойти каноничным путём и собирать `all` и `any` отдельно.


### Для чего при сборке cdeb запускаются и `--arch-all`, и `--arch-any`?

Раньше для сборки пакетов отдельно использовались `wbdev cdeb` (для `any`) и
`wbdev ndeb` (для `all`). Это было очень актуально во времена `wheezy`, когда
не было ещё multiarch, и пакеты для Wiren Board приходилось собирать в chroot
с qemu. Тогда для экономии времени сборки (qemu медленный) сделали отдельно
команду `ndeb`, которой собирали `all`-пакеты прямо в Docker-окружении.

Потом мы перешли на sbuild, и разница между `cdeb` и `ndeb` стала размываться,
потому что для обеих команд уже использовалось sbuild-окружение, только с
разным аргументом `--host`.

*Так получилось*, что при переходе на релизную систему, когда для сборки
стало нужно указывать, для какой платформы происходит сборка (wb5/wb6/wb7),
добавление наших репозиториев (`http://deb.wirenboard.com/wbX/<deb-release>`)
делалось только в `cdeb`. Для `ndeb` появился репозиторий `dev-tools`, который
нужен скорее для сборки пакетов, нужных нам на производстве и для CI.

Пока наши all-пакеты не зависели друг от друга при сборке, можно было продолжать
пользоваться такой системой, выбирая в зависимости от типа пакета `cdeb` или `ndeb`.
При разработке wb-device-manager нам понадобились all-зависимости из нашего репозитория.

В этот момент @webconn решил, что пора объединять `cdeb` и `ndeb` - так получается
меньше пайплайнов для CI и не надо дублировать код в devenv. Также меньше возможностей
ошибиться при сборке - скрипты сами сделают всё, что нужно.

`ndeb` с этого момента стал deprecated, о чём пишется WARNING.


### Почему в Python-библиотеках не пишем Multi-Arch в пакетах?

Как минимум потому что это не делают даже в Debian.
