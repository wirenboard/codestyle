# Дебианизация (нового/существующего проекта)

Disclaimer: данный гайдлайн стоит воспринимать как выжимку полезностей, а не строгую последовательность действий.

Предполагаемый путь: _понять, что требуется -> посмотреть в [типовых кейсах](#примеры-разных-сценариев) аналогичное -> непонятно - почитать здесь -> отправиться в документацию уже зная, что искать_.

## Тезисно
Для удобного распространения и установки софта, его пакетируют. Deb - самый популярный формат пакетов (используется в *Ubuntu, Debian, у нас на контроллерах). Настройка проекта, чтобы он собирался в .deb пакеты - _дебианизация_.

_Hint:_ .deb лучше всего устанавливать так: ``apt update; apt install -y ./файл.deb`` (через apt, а не dpkg; для автоматического разрешения зависимостей).


### Устройство deb-пакета

- _Исходная система_ - где происходит сборка deb-пакета. В терминологии debian - **build**-система
- _Целевая система_ - куда устанавливается пакет. В терминологии debian - **host**-система

Исполняемые файлы (результаты сборки проекта/скрипты/...) + запаковка их в .deb-пакет (да-да, почти обычный архив) + мета-информация (зависимости/changelog/...) + dh-скрипты (выполняются на целевой системе при/перед/после установки/удаления пакета) = deb-пакет.

Со стороны разработчика, _deb-пакет = source-пакет + binary-пакет/ы_. Из одного source-пакета получаются один или несколько binary-пакетов (которые уже и устанавливаются на целевую систему). См ``debian/control`` далее.

В корень проекта добавляется директория _debian_ с магическими файлами.

Для успешной дебианизации нужно:
- уметь собирать проект
- "рассказать" dh-утилитам, как проект собирается


## Минимальная дебианизация
Минимально необходимые магические файлы в директории _debian_ - это:
- **control** - описывает, какие binary-пакеты получаются из source-пакета; зависимости между пакетами
- **changelog** - чейнджлог; лучше делать утилитой ``dch``
- **compat** - совместимость с вспомогательными скриптами debian. Ставить 9 и не думать (_с переходом на bullseye - ставить 11_)
- **copyright** - можно оставлять пустым
- **rules** - запуск системы сборки (не обязательно make!)
Подробно можно почитать в [доках](https://www.debian.org/doc/manuals/maint-guide/dreq.ru.html)

### Control - всему голова
Именно здесь живут основные настройки пакета. Подробно и понятно о содержании файла control можно почитать в [доке](https://www.debian.org/doc/debian-policy/ch-controlfields).
Дополнительно для нас, обязательны поля:
- ``Homepage``: страница проекта на нашем github. Нужно для ci.
- ``Maintainer``: сотрудник, ответственный за репозиторий. Добавляет порядка.

### О чейнджлогах
Почитав умные статьи вроде [этой](https://cbea.ms/git-commit/), мы приняли решение утвердить формат записей в чейнджлог (и commit messages): _Следует писать на английском в повелительном наклонении. Образец: "add <что_было_добавлено>" - ок. "add**ed** <что_было_добавлено>" или "<что_было_добавлено> is added" - не ок_.
Вносим записи в changelog пакета **при любом** изменении кода (попадающего в master / release*).

### Магические файлы
Об опциональных файлах в директории debian можно почитать в [доке](https://www.deNBbian.org/doc/manuals/maint-guide/dother.ru.html). _Если из одного source-пакета собираются несколько бинарных пакетов - справедливо: вместо <файл_магии> - назвать <название_бинарного_пакета>.<файл_магии>_ (будет работать для указанного бинарного пакета, соответственно).

Чаще всего пригождаются:
- ``debian/packagename.dirs``: директории, необходимые для работы проекта (но не необходимые для установки; например - файлы, появляющиеся в процессе работы). Удаляются при удалении пакета.
- ``debian/packagename.install``: помещаем сюда файлы, которые нужно положить в пакет (если это не делает make install).
- ``debian/packagename.service``: systemd-сервис. Устанавливается автоматически при установке пакета (для автозапуска - прописать соответствующее в rules).
- ``debian/packagename.displace``: замена существующих файлов на файлы из пакета. При удалении пакета, исходные файлы возвращаются. Подробнее - в [доках](https://manpages.debian.org/jessie/config-package-dev/dh_configpackage.1).
- ``debian/packagename.preinst/postinst/prerm/postrm/...``: maintainer-скрипты. Выполняются на разных этапах установки/удаления пакетов. Подробно почитать, что происходит при установке/удалении пакета можно в [доках](https://wiki.debian.org/MaintainerScripts).

### Как файлы проекта попадают в пакет
Директория debian в проекте (исходная система) содержит структуру директорий относительно корня целевой системы. По умолчанию, запуск системы сборки (rules) в конце-концов вызывает _make install_ (относительно директории _debian/_ проекта).

В дебианизации можно переопределить практически что угодно. Например, если нужно пакетировать скрипты/уже готовые бинарники - можно в файле rules не вызывать систему сборки (её вообще может не быть), а добавить в debian/ файл <бинарный_пакет>.install, в котором прописано, какой файл куда класть.

**=> для попадания файлов проекта в пакет, должно быть что-то из:**
- ``Makefile`` с таргетом _install_ внутри
- ``debian/packagename.install`` с описанием внутри, что куда класть

### Сборка
В общем случае, сборка пакета инициируется запуском ``dpkg-buildpackage -rfakeroot -us -uc`` в корне проекта. При сборке бинарников системой сборки, вызываемой в файле rules, могут возникнуть проблемы, связанные с архитектурой => при разработке под WB, **пакеты собирать стоит через [wbdev](https://github.com/wirenboard/wirenboard/blob/master/README.md)**. _Стоит не забывать периодически обновлять devenv (``docker pull contactless/devenv``)_.

Для сборки - выполнить в корне проекта:
- C/C++: ``wbdev cdeb``
- Go: ``wbdev gdeb``
- Noarch (Python/Bash/wbrules/configs/...): ``wbdev ndeb``

### Сборка на билдсервере (далее - Jenkins)
То же самое рабочее окружение (wbdev) используется и для сборки проектов на Jenkins. Здесь мы используем подход _infrastructure as code_, поэтому сборка проектов реализована в виде пайплайнов (подробнее про пайплайны у нас можно почитать [на intwiki](https://intwiki.contactless.ru/dokuwiki/doku.php?id=soft:jenkins)).

Jenkins собирает проект при:
- пуше в веточку
- открытии pr

Концептуально это сделано с помощью: веб-хуков github; плагина для Jenkins (позволяющего описывать этапы сборки в виде кода); непосредственно этапов сборки.

Для того, чтобы Jenkins понимал, что этот проект ему надо собирать, **нужно добавить в корень проекта файл ``Jenkinsfile``** с описанием, что ему делать ([пайплайн](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/)).

Типовые сценарии сборки Jenkins'ом у нас реализованы, и живут [здесь](https://github.com/wirenboard/jenkins-pipeline-lib). Соответственно, для сборки рядового проекта, в Jenkinsfile часто достаточно:
- С/C++: ``buildDebSbuild defaultTargets: 'current-armhf'``
- Go: ``buildDebGolangWbgo()``
- Noarch (Bash/Python/wb-rules/...): ``buildDebArchAll()``

Параметры для вызовов можно подглядеть в соответствующе названных файлах в репозитории выше. Как эти параметры передаются - можно подглядеть в [wb-mqtt-serial](https://github.com/wirenboard/wb-mqtt-serial/blob/master/Jenkinsfile).


## Успешный старт нового репозитория
Для того, чтобы проект заехал в нашу инфраструктуру (собирался на Jenkins, вписался в систему релизов), нужно (со стороны github):

- дать доступ группе ``buildserver-robots`` - для релизной системы
- сделать дебианизацию
- добавить Jenkinsfile - настройки сборки на билдсервере


## Примеры разных сценариев
Дебианизация и документация по ней - обширный мир, который можно уйти надолго => часто бывает проще подсмотреть типовой сценарий и сделать аналогично:

[serial_tool](https://github.com/wirenboard/serial_tool) - готовый скрипт, который надо положить в /usr/bin/. Собирается Make'ом; в rules прописан вызов Make'a.

[wb-mcu-fw-updater](https://github.com/wirenboard/wb-mcu-fw-updater) - состоит из "бинарника" и библиотеки. Из одного source-пакета получается 2 binary-пакета. Собирается pubuild'ом вместо Make; в rules прописан вызов pybuild. _Каноничный способ дебианизации python-проекта_.

[wb-demokit-configs](https://github.com/wirenboard/wb-demo-kit-configs) - нужно положить на контроллер некоторые файлы (с заменой существующих!). В этом нам помогают .displace файлы.

[wb-mcu-fw-flasher](https://github.com/wirenboard/wb-mcu-fw-flasher) - классическая сборка Makefile'ом; в rules просто вызывается make. Прописанное в .dirs очищается при удалении пакета.

[test-suite](https://github.com/wirenboard/test-suite/tree/master/debian) - сложная дебианизация. Из одного source собирается куча binary-пакетов (каждый с разными файлами). Действия перед/после установки/удаления пакета в целевой системе прописаны в .postinst/.postrm/...


## Продвинутые техники
- Диалоговое окно с настройками (на синем фоне) формируется утилитой debconf (проще всего понять на примерах в [test-suite](https://github.com/wirenboard/test-suite/tree/master/debian)).
- Про взаимоотношения между пакетами можно почитать в [доке](https://wiki.debian.org/PackageTransition).
