# Дебианизация (нового/существующего проекта)

## Тезисно
Для удобного распространения и установки софта, его пакетируют. Deb - самый популярный формат пакетов (используется в *Ubuntu, Debian, у нас на контроллерах). Настройка проекта, чтобы он собирался в .deb пакеты - _дебианизация_.

_Hint:_ .deb лучше всего устанавливать так: ``apt update; apt install -y ./файл.deb`` (через apt, а не dpkg; для автоматического разрешения зависимостей).


### Устройство deb-пакета

- _Исходная система_ - где происходит сборка deb-пакета
- _Целевая система_ - куда устанавливается пакет

Исполняемые файлы (результаты сборки проекта/скрипты/...) + запаковка их в .deb-пакет (да-да, почти обычный архив) + мета-информация (зависимости/changelog/...) + dh-скрипты (выполняются на целевой системе при/перед/после установки/удаления пакета) = deb-пакет.

Со стороны сборки, _deb-пакет = source-пакет + binary-пакет/ы_. Из одного source-пакета получаются один или несколько binary-пакетов (которые уже и устанавливаются на целевую систему).

В корень проекта добавляется директория _debian_ с магическими файлами.

Для успешной дебианизации нужно:
- уметь собирать проект
- "рассказать" dh-утилитам, как проект собирается


## Минимальная дебианизация
Минимально необходимые магические файлы в директории _debian_ - это:
- **control** - описывает, какие binary-пакеты получаются из source-пакета; зависимости между пакетами
- **changelog** - чейнджлог; лучше делать утилитой ``dch``
- **compat** - совместимость с вспомогательными скриптами debain. Ставить 9 и не думать
- **copyright** - можно оставлять пустым
- **rules** - запуск системы сборки (не обязательно make!)

### Как файлы попадают в пакет
Директория debian в проекте (исходная система) содержит структуру директорий относительно корня целевой системы. По умолчанию, запуск системы сборки (rules) генерирует артефакты, которые кладутся в debian/.

В дебианизации можно переопределить практически что угодно. Например, если нужно пакетировать скрипты/уже готовые бинарники - можно в файле rules не вызывать систему сборки (её вообще может не быть), а добавить в debian/ файл <бинарныый_пакет>.install, в котором прописано, какой файл куда класть.

### Сборка
В общем случае, сборка пакета инициируется запуском ``dpkg-buildpackage -rfakeroot -us -uc`` в корне проекта. При сборке бинарников системой сборки, вызываемой в файле rules, могут возникнуть проблемы, связанные с архитектурой => **пакеты собирать стоит через [wbdev](https://github.com/wirenboard/wirenboard/blob/master/README.md)**. _Стоит не забывать периодически обновлять devenv (``docker pull contactless/devenv``)_.

Для сборки - выполнить в корне проекта:
- C/C++: ``wbdev cdeb``
- Go: ``wbdev gdeb``
- Noarch (Python/Bash/wbrules/configs/...): ``wbdev ndeb``

### Сборка на билдсервере (далее - Jenkins)
То же самое рабочее окружение (wbdev) используется и для сборки проектов на Jenkins. Здесь мы используем подход _infrastructure as code_, поэтому сборка проектов реализована в виде пайплайнов (подробнее про пайплайны у нас можно почитать [на intwiki](https://intwiki.contactless.ru/dokuwiki/doku.php?id=soft:jenkins)).

Jenkins собирает проект при:
- пуше в веточку
- открытии pr

Концептуально это сделано с помощью: веб-хуков github; плагина для Jenkins (позволяющего описывать этапы сборки в виде кода); непосредственно этапов сборки.

Для того, чтобы Jenkins понимал, что этот проект ему надо собирать, нужно добавить в корень проекта файл ``Jenkinsfile`` с описанием, что ему делать (добавив в любую ветку проекта, будут собираться все ветки).

Типовые сценарии сборки Jenkins'ом у нас реализованы, и живут [здесь](https://github.com/wirenboard/jenkins-pipeline-lib). Соответственно, для сборки рядового проекта, в Jenkinsfile должен быть вызов:
- С/C++: ``buildDebSbuild()``
- Go: ``buildDebGolangWbgo()``
- Noarch (Bash/Python/wb-rules/...): ``buildDebArchAll()``

Параметры для вызовов можно подглядеть в соответствующе названных файлах в репозитории выше.


## Примеры разных сценариев
[serial_tool](https://github.com/wirenboard/serial_tool) - готовый скрипт, который надо положить в /usr/bin/. Собирается Make'ом; в rules прописан вызов Make'a.

[wb-mcu-fw-updater](https://github.com/wirenboard/wb-mcu-fw-updater) - состоит из "бинарника" и библиотеки. Из одного source-пакета получается 2 binary-пакета. Собирается pubuild'ом вместо Make; в rules прописан вызов pybuild.

[wb-demokit-configs](https://github.com/wirenboard/wb-demo-kit-configs) - нужно положить на контроллер некоторые файлы (с заменой существующих!). В этом нам помогают .displace файлы.

[wb-mcu-fw-flasher](https://github.com/wirenboard/wb-mcu-fw-flasher) - классическая сборка Makefile'ом; в rules просто вызывается make. Прописанное в .dirs очищается при удалении пакета.

[test-suite](https://github.com/wirenboard/test-suite/tree/master/debian) - сложная дебианизация. Из одного source собирается куча binary-пакетов (каждый с разными файлами). Действия перед/после установки/удаления пакета в целевой системе прописаны в .postinst/.postrm/... _Pro hint:_ диалоговое окно с настройками (на синем фоне) формируется утилитой debconf (проще всего понять на примерах в проекте).
