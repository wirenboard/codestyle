Процесс разработки проектов Wiren Board с использованием Git, Github, JIRA
============================

Общее
-------------

Процесс построен так: описание задачи в нашей джире, работа над прошивкой в нашем гите на гитхабе. 
Работать нужно в ветке в гите, всё коммитить, в конце прибираться и сделать pull-request. 
Дальше на этот PR смотрит ответсвенный человек из числа коллег и либо принимает как есть, либо как-то комментирует и просит изменений.


Документирование
-------------------------
Новую функциональность после принятия PR (но до релиза) нужно описать в нашей публичной вики и хорошо протестировать. 

Если разработка касается прошивок, то нужно помнить, что железки чаще всего используют с нашим линуксовым контроллером, так что потом с ним тоже надо протестировать.


Стайлгайд
------------
Код пишем одинаково. Что-то описано в стайлгайде (https://github.com/contactless/codestyle/blob/master/embedded_c.en.md и рядом), что-то выяснится после ревью пулл-реквестов. Если чего-то нет в стайлгайде, то лучше посмотреть как написано рядом.


Создание веток в Git
--------------------

В этом разделе описана работа с ветками _до создания PR_. Работа с ветками, для которых уже создан PR, отличается, смотри следующий раздел.

  1. Получаем последнее состояние ветки `main` (или `master`).
  2. Создаём ветку. Допустимые имена веток:

  - `feature/XXXXX-my-description` или `bugfix/XXXXX-my-description` (`XXXXX` - номер тикета в bitrix24);
  - `feature/my-description` или `bugfix/my-description`, если тикета нет (например, быстро что-то исправили);
  - `tmp/username/my-description` для временных веток.

  3. Делаем что-то в ветке. До того, как был создан PR, с веткой можно делать что угодно: перетаскивать (rebase), сливать коммиты и так далее.
     Соответственно, можно делать `git push -f`. Нельзя писать в чужие ветки без согласования с автором. И нет смысла ожидать, что чужая ветка
     будет изменяться предсказуемо, если это не согласовано.
  4. Перед подготовкой PR нужно сделать следующее:

  - убедиться, что история линейна (ветка - последовательность из одного или нескольких коммитов без мержей с другими ветками, в т.ч. `main` (или `master`));
  - в ветке адекватное количество коммитов (часто достаточно одного, желательно - до 5);
  - каждый коммит имеет смысловую нагрузку и соответствует какому-то атомарному изменению. Например, нельзя в одном коммите исправлять
    форматирование и добавлять новую логику;
  - каждый коммит имеет адекватное описание. Например, `fix some bugs` - плохое описание. В хорошем указано, что изменилось и зачем это нужно,
    идеально было бы сослаться на тикет (по номеру) или обсуждение в техподдержке;
  - очень желательно, чтобы в каждом коммите ветки проект собирался и получалось что-то адекватное;
  - если проект собирается в deb-пакет или в файл прошивки с версией, то нужно добавить запись в changelog. Это можно сделать в одном коммите с
    изменениями, если их не очень много, или отдельным коммитом в конце. Правила обновления номера версии - semver (https://semver.org/lang/ru/).

    В приведении ветки в порядок помогут эти команды: `git rebase -i` и `git add -p`, можно почитать об этом в мане или в интернете.

    Если строгое деление на коммиты не обязательно и их можно объединить в один перед слиянием, можно не объединять их заранее,
    а просто выполнить слияние кнопкой "Squash and merge". Адекватные описания коммитов и обновление версии пакета всё ещё обязательны.

  5. Создаём PR. После создания PR ветка перестаёт быть только твоей собственностью, и мы начинаем действовать по инструкции из следующего раздела.

Работа с PR
-----------

Работа с веткой в PR отличается от обычной работы с веткой, потому что теперь в игру вступают инструменты Github,
которые капризно относятся к изменениям истории.

**Особенности работы с веткой в PR**:

  - **нельзя** менять историю! То есть, мораторий на любые действия, кроме добавления коммитов.
    Github может потерять обсуждения, привязанные к коду. Все изменения в рамках PR создаём новыми коммитами,
    не забывая о правилах оформления коммитов из описания выше.

**Жизненный цикл PR**:

  1. Создание. В этот момент нужно добавить как минимум 1 ревьювера. Если сомневаешься, добавь мейнтейнера пакета (указан в `debian/control`) или спроси в чате.
  2. Процесс ревью. В это время другие люди смотрят изменения, идёт обсуждение спорных моментов, предлагаются правки.
  3. Внесение правок. Делаем это отдельными коммитами сверху. Можно разделять правки, относящиеся к разным исходным коммитам; это позволит
     потом снова привести историю в порядок.
  4. После того, как все ревьюверы согласны с изменениями и пройдены тесты на CI, переходим к подготовке к слиянию.

**Слияние (merge)**. Здесь возможно несколько сценариев:

  - **Сценарий 1**. Изменений в ходе ревью не было, и ветка `main` (или `master`) не обновилась за время существования PR.
  - **Сценарий 2**. Изменений не было, но ветка `main` (или `master`) продвинулась по истории.
  - **Сценарий 3**. Были внесены изменения в ветку в ходе ревью.

В первом сценарии всё просто. Если пройдены тесты и получен approve, всё хорошо, просто нажимаем кнопку `Merge`.
Если в ветке был всего один коммит, допустимо выбрать вариант `Squash and merge`, в остальных случаях **так делать нельзя**!
Если коммитов было несколько, обязательно нужно вливать с добавлением merge-коммита.

Во втором сценарии возможно два варианта:

 - если ветка состояла из одного коммита и `main` (или `master`) продвинулась вперёд, то можно сделать `Squash and merge`. Это безопасно,
   потому что CI проверяет PR на корректность с учётом слияния с `main` (или `master`) _(стоит внимательно проверить, будет ли перезапущена
   сборка после обновления `main` (или `master`))_;
 - если ветка состояла из нескольких коммитов, то нужно действовать как в третьем сценарии, создавать новый PR с ребейзом.

Третий сценарий самый сложный. В нём нужно будет сделать `rebase` ветки на последнее состояние `master` и слить коммиты с исправлениями
с исходными коммитами в ветке. Для этого делаем следующее:

  1. Закрываем существующий PR без слияния.
  2. Создаём из исходной ветки новую с именем `<имя ветки>-rebaseX`, где X - номер итерации (начиная с 1) на случай, если понадобится
     несколько раз подряд переносить ветку. Старую ветку теперь обновлять нельзя.
  3. Вносим изменения в историю:

  - переносим ветку на вершину `main` (или `master`);
  - сливаем коммиты с правками с исходными коммитами.

  4. Создаём новый PR с новой веткой. Ссылаемся на новый PR в комментариях к старому, оставляем ссылку на старый в новом.
     В общем, наводим связность.
  5. _<сознательность\_моде>_ Если в процессе rebase не было сделано никаких **новых** изменений (например, для решения
    конфликтов с новым `main` (или `master`), то вливать PR можно без ревью. Правила вливания как в первом сценарии.
  6. Если были внесены изменения, с которыми стоит ознакомиться команде, то нужно добавлять ревьюверов и весь процесс повторяется сначала.

После принятия PR и слияния все получившиеся ветки, в том числе из закрытых PR, нужно удалить. Удаление ветки в
принятом PR делается нажатием кнопки в интерфейсе Github, остальные же пока нужно удалить вручную. В качестве задачи для
того, кому будет не лень, можно предложить автоматизировать это с помощью Jenkins.

Стабильные версии и релизы
--------------------------

После введения системы регулярных релизов (https://wirenboard.com/wiki/Software_Releases) то, что находится в `main` (или `master`), не является стабильным.

Код с вершины `main` (или `master`) автоматически загружается в `unstable` (и, следовательно, в `testing`, если он не заморожен).

Версия кода становится стабильной после включения её в релизный список и выпуска релиза. В момент выпуска релиза коммит с выпущенной
версией помечается веткой с именем `release/wb-YYYY` (`YYYY` - номер релиза).

Исправления, вносимые в репозиторий после выпуска релиза, должны составлять линейную историю в ветке `release/wb-YYYY`.
Этого можно достичь несколькими способами:

 1. Если исправление вышло сразу после публикации релиза, и ветка `main` (или `master`) находится в той же позиции, что `release/wb-YYYY`,
    то после вливания ветки с исправлением в `main` (или `master`) и добавления новой версии в релизный список, ветка `release/wb-YYYY`
    переносится на новый коммит в `main` (или `master`) (типа fast-forward merge).

В этом случае номер версии изменяется естественным образом согласно semver.


 2. Если после выпуска релиза в `master` оказались изменения, которые не должны попасть в релиз, в месте `release/wb-YYYY` создаётся
    ветка с именем `feature/XXXXX-description/release/wb-YYYY`, в которую вносятся нужные исправления. После этого создаётся PR
    из новой ветки в `release/wb-YYYY`.

Во втором случае номер версии формируется как версия уже выпущенного пакета и суффикс `-wbZ`, где `Z` - номер патча в этот релиз.

Например, если изначально в релиз вошла версия `2.3.4`, но в процессе потребовалось добавить патч в выпущенную версию,
номер новой версии в релизе будет `2.3.4-wb1`. Если в уже пропатченную версию потребовались изменения, то номер новой
версии будет `2.3.4-wb2` и так далее. _В правила нумерации версий в релизах в отдельных случаях могут быть внесены изменения_.


Связь с bitrix24
----------------

Настроена связь git и bitrix24: ветки с названием X/N-Y (например: feature/12345-bitrix-integration), автоматически привязываются к задаче с номером N в битриксе. 
