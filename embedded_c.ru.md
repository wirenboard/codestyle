Wiren Board Embedded C Style Guide
========================

Этот документ описывает рекомендации по написанию легко читаемого и хорошо организованного кода на языке C для embedded-разработки.

## Именование
### Общее
В embedded C не используется стиль CamelCase, вместо него применяется snake_case. В именах функций и переменных допускаются **только строчные буквы**, слова разделяются символом подчеркивания (`_`).

### Файлы и модули
1. При добавлении нового модуля размещайте его в отдельной библиотеке.
2. Избегайте файлов с именами типа *peripherals.h*.
3. Имя файла должно отражать суть модуля. Используйте *mcp230xx.h* вместо *gpio_chip.h*.
4. Разделяйте функциональность модулей для повышения повторного использования кода. Базовые функции для работы с ИС — в одном файле, задачи — в другом. Например, *mcp230xx.h* содержит драйвер, а *wbio-dio.h* использует его функции.

### Функции
В C нет пространств имен и классов, поэтому рекомендуется добавлять префикс библиотеки к каждой функции, даже если она static и используется только внутри библиотеки:
```C
int pin_value = mcp230xx_read_gpio();
ads1015_set_config(ADS_CONFIG_1);
```
То же касается *define*:
```C
#define MCP23008_IODIR                  0x00
#define MCP23008_IPOL                   0x01
#define MCP23008_GPINTEN                0x02
#define MCP23008_DEFVAL                 0x03
#define MCP23008_INTCON                 0x04
```

### Имена вариантов enum
Нужно выбирать осмысленное имя типа enum, и все варианты должны начинаться с префикса данного имени.

Хорошее именование: по вариантам понятно, о каком enum идет речь:
```C
enum w1_transaction {
    W1_TRANSACTION_SEND,
    W1_TRANSACTION_RECEIVE
}
```

Плохое именование: невозможно понять, к какому enum принадлежит вариант, пока не посмотрим определение:
```C
enum w1_transaction {
    W1_PROTOCOL_SEND,
    W1_PROTOCOL_RECEIVE
}
```

Плохое именование: слишком длинные имена, можно выбрать более короткий вариант без потери смысла:
```C
enum w1_protocol_transaction {
    W1_PROTOCOL_TRANSACTION_SEND,
    W1_PROTOCOL_TRANSACTION_RECEIVE
}
```

## Объявления
1. Функции, не предназначенные для вызова вне библиотеки, должны быть объявлены как *static*.
2. Прототипы static-функций размещаются в *.c* файле.
3. *#define*, используемые только в *.c*, также должны быть там.
4. В заголовочном файле размещаются только необходимые для использования библиотеки *define* и функции.
5. Не используйте "магические" константы. Вместо этого используйте *define*:
```C
#define MCP230xx_REG_IOCON_BANK (1 << 2)
...
uint16_t gpio_config = mcp230xx_read_config();
if (gpio_config & MCP230xx_REG_IOCON_BANK) {
...
```
6. Также в заголовочном файле могут помещаться `static inline` функции, если они, например, используются как заглушки или обёртки для других функций.

7. При переопределении или определении новых типов данных в конце названий добавляется `_t`:
```C
typedef struct {
    uint16_t address;
    uint16_t data;
} hold_reg_t;
```

8. Имена структур не должны иметь в названии `_t`:
```C
struct hold_reg {
    uint16_t address;
    uint16_t data;
};
```

## Макросы C
Использование препроцессора C не рекомендуется, так как это усложняет чтение и поддержку кода. По возможности используйте средства языка C.

Типовые случаи применения макросов:
* Определение констант (`#define`), например, размеров массивов, параметров конфигурации, адресов регистров.
* Включение/отключение частей прошивки через `#if` и подобные директивы (желательно на уровне модуля).
* Компиляторные приёмы, невозможные иначе (например, `assert`). Старайтесь ограничивать такими случаями только низкоуровневые библиотеки.

Если в макросе используются выражения, оборачивайте их в `do {} while (0)`. Макросы, имитирующие функции, должны вести себя как функции. Например, `START_TIMER();` вместо `START_TIMER;`. Все макросы именуются ЗАГЛАВНЫМИ буквами.

Возможные альтернативы:
* `if` с условием, вычисляемым на этапе компиляции, вместо `#if`;
* `const`-переменные вместо `#define`;
* `static inline`-функции вместо макросов с выражениями.

## Кодировка
Все файлы должны быть в кодировке UTF-8.

## Конец файла
Файл всегда заканчивается переводом строки.

## Выравнивание
Пробелы

1. Отступы — 4 пробела между блоками, не использовать символ табуляции (TAB).
2. Знаки бинарных операций отделяются от переменных пробелами, а знаки унарных операций — нет.
```C
a += b / c;
c++;
c &= ~d;
```
3. Пробелы между ключевыми словами (`if`, `while`, `do`, `for`) и открывающей скобкой выражения.
4. Аргументы функций перечисляются без пробелов вокруг скобок. Когда аргументов несколько, запятая ставится сразу после аргумента, после запятой — пробел:
```C
task_schedule(adc_start_periodic_conversion_task_id, ADC_FILTRATION_PERIOD_MS);
```
5. Значения макросов, которые именуют константы, должны быть расположены от 40 до 60-го знакоместа, кратно 4 символам.
Это нужно для того, чтобы оставить место для макросов с длинными именами, которые могут быть потенциально добавлены позже в процессе разработки.

Отступы и пробелы можно проверять, например, используя команду `git diff`. С помощью команды `git diff master` проверяется, что не изменено форматирование уже написанного ранее кода относительно мастер-ветки.

Не используйте отступы для выравнивания.

Примеры плохого кода:
```C
static uint16_t task_next_free_id[TASK_TYPE_NUMBER] = {GET_TASK_ID(TASK_IMMEDIATE, 0),
                                                       GET_TASK_ID(TASK_BACKGROUND, 0)};
```

```C
    hlw8012_channels_state[channel].energy_factor = fix16_to_int(fix16_mul(fix16_div(fix16_from_int(hlw8012_channel_defs[channel].energy_unit_time),hlw8012_channels_state[channel].value_factor),F16(HLW8012_PULSE_COUNTING_FACTOR)));
```

```C
    hlw8012_channels_state[channel].energy_factor = fix16_to_int(fix16_mul(fix16_div(fix16_from_int(hlw8012_channel_defs[channel].energy_unit_time),
                                 hlw8012_channels_state[channel].value_factor),F16(HLW8012_PULSE_COUNTING_FACTOR)));
```

Примеры хорошего кода:

```C
static uint16_t task_next_free_id[TASK_TYPE_NUMBER] = {
    GET_TASK_ID(TASK_IMMEDIATE, 0),
    GET_TASK_ID(TASK_BACKGROUND, 0)
};
```

```C
    hlw8012_channels_state[channel].energy_factor = fix16_to_int(
        fix16_mul(
            fix16_div(
                fix16_from_int(
                    hlw8012_channel_defs[channel].energy_unit_time
                ),
                hlw8012_channels_state[channel].value_factor
            ),
            F16(HLW8012_PULSE_COUNTING_FACTOR)
        )
    );
```

Пример расстановки пробелов при объявлении массива:
```C
static const uint8_t array_example[] = { 0xAA, 0xBB, 0xCC, 0xDD, 0xEE };
```

## Комментарии
Комментарии пишутся после строки (короткие) или до строки (длинные):
```C
код         // короткий комментарий
```
или
```C
// длинный комментарий
код
```
```//``` выравнивается по позиции, кратной 4 символам (в редакторе vscode клавишей TAB в режиме 4 пробела вместо табуляции).
Текст от знака ```//``` отделяется пробелом.

## Расстановка скобок
Даже если тело условного блока состоит из одной строки, оно заключается в фигурные скобки.

Перенос скобки на следующую строку начала определения осуществляется в функциях и многострочных условиях (`if`, `else if`), в остальных случаях — нет.
Расстановка скобок:
```C
void function(void)
{
    if (a == b) {
        // single str action use brackets
    }

    if (c == d) {
        // do if equal
    } else {
        // do if not equal
    }

    if ((a == b) ||
        (c == d))
    {
        // multi str condition use statement body open bracket with newline
    } else if ((a != b) &&
               (c != e))
    {
        // multi str condition use statement body open bracket with newline
    } else if (c == e) {
        // single str condition use statement body open bracket with one line
    }
}

void function(void)
{
    return;
}

```
Скобки ставятся всегда, даже когда тело блока — одна строка, и даже когда его нет:
```C
while () {};

if () {
    return 0;
} else {
    return 1;
}
```

Операции всегда выделяются скобками, даже если порядок действий очевиден:
```C
(a || b && !c) -> (a || (b && (!c)))
```

## Ветвления
Запрещается использование тернарных операций, так как они усложняют понимание кода.

```C
int a = (cond) ? var1 : var2;
```

Если условие содержит логическое И, рекомендуется сделать два вложенных if. Такой подход нагляднее демонстрирует условия выполнения, а также заставляет задуматься о порядке проверки условий и упрощении кода.

```
if (cond1) {
    if (cond2) {
        ...
    }
}
```

## Логические выражения

Запрещается использовать логические операции где-либо, кроме операторов условия:

```C
return (enabled_ch_mask & (1 << channel)) != 0;
```

или

```C
x = (enabled_ch_mask & (1 << channel)) != 0;
```

Проверка логического условия в выражении присваивания затрудняет понимание. Вместо этого предлагается написать обычный читаемый if.

```C
if (enabled_ch_mask & (1 << channel)) {
    return 1;
}
return 0;
```

или

```C
x = 0;
if (enabled_ch_mask & (1 << channel)) {
    x = 1;
}
```
